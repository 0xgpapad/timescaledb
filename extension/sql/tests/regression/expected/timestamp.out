psql:include/create_clustered_db.sql:12: NOTICE:  installing required extension "dblink"
psql:include/create_clustered_db.sql:12: NOTICE:  installing required extension "postgres_fdw"
psql:include/create_clustered_db.sql:12: NOTICE:  installing required extension "hstore"
psql:include/create_clustered_db.sql:17: NOTICE:  installing required extension "dblink"
psql:include/create_clustered_db.sql:17: NOTICE:  installing required extension "postgres_fdw"
psql:include/create_clustered_db.sql:17: NOTICE:  installing required extension "hstore"
psql:include/create_clustered_db.sql:23: NOTICE:  installing required extension "dblink"
psql:include/create_clustered_db.sql:23: NOTICE:  installing required extension "postgres_fdw"
psql:include/create_clustered_db.sql:23: NOTICE:  installing required extension "hstore"
\c meta
SELECT add_cluster_user('postgres', NULL);
 add_cluster_user 
------------------
 
(1 row)

SELECT set_meta('meta' :: NAME, 'localhost');
 set_meta 
----------
 
(1 row)

SELECT add_node('Test1' :: NAME, 'localhost');
 add_node 
----------
 
(1 row)

SELECT add_node('test2' :: NAME, 'localhost');
 add_node 
----------
 
(1 row)

\c Test1
-- Utility function for grouping/slotting time with a given interval.
CREATE OR REPLACE FUNCTION date_group(
    field           timestamp,
    group_interval  interval
)
    RETURNS timestamp LANGUAGE SQL STABLE AS
$BODY$
    SELECT to_timestamp((EXTRACT(EPOCH from $1)::int /
        EXTRACT(EPOCH from group_interval)::int) *
        EXTRACT(EPOCH from group_interval)::int)::timestamp;
$BODY$;
CREATE TABLE PUBLIC."testNs" (
  "timeCustom" TIMESTAMP NOT NULL,
  device_id TEXT NOT NULL,
  series_0 DOUBLE PRECISION NULL,
  series_1 DOUBLE PRECISION NULL,
  series_2 DOUBLE PRECISION NULL,
  series_bool BOOLEAN NULL
);
CREATE INDEX ON PUBLIC."testNs" (device_id, "timeCustom" DESC NULLS LAST) WHERE device_id IS NOT NULL;
SELECT * FROM create_hypertable('"public"."testNs"', 'timeCustom', 'device_id', associated_schema_name=>'testNs' );
 create_hypertable 
-------------------
 
(1 row)

SELECT set_is_distinct_flag('"public"."testNs"', 'device_id', TRUE);
 set_is_distinct_flag 
----------------------
 
(1 row)

\c Test1
INSERT INTO PUBLIC."testNs"("timeCustom", device_id, series_0, series_1) VALUES
('2009-11-12T01:00:00+00:00', 'dev1', 1.5, 1),
('2009-11-12T01:00:00+00:00', 'dev1', 1.5, 2),
('2009-11-10T23:00:02+00:00', 'dev1', 2.5, 3);
SELECT _iobeamdb_meta_api.close_chunk_end_immediate(c.id)
FROM get_open_partition_for_key((SELECT id FROM _iobeamdb_catalog.hypertable WHERE table_name = 'testNs'), 'dev1') part
INNER JOIN _iobeamdb_catalog.chunk c ON (c.partition_id = part.id);
 close_chunk_end_immediate 
---------------------------
 
(1 row)

INSERT INTO PUBLIC."testNs"("timeCustom", device_id, series_0, series_1) VALUES
('2009-11-10T23:00:00+00:00', 'dev2', 1.5, 1),
('2009-11-10T23:00:00+00:00', 'dev2', 1.5, 2);
SELECT * FROM PUBLIC."testNs";
     timeCustom      | device_id | series_0 | series_1 | series_2 | series_bool 
---------------------+-----------+----------+----------+----------+-------------
 2009-11-12 01:00:00 | dev1      |      1.5 |        1 |          | 
 2009-11-12 01:00:00 | dev1      |      1.5 |        2 |          | 
 2009-11-10 23:00:02 | dev1      |      2.5 |        3 |          | 
 2009-11-10 23:00:00 | dev2      |      1.5 |        1 |          | 
 2009-11-10 23:00:00 | dev2      |      1.5 |        2 |          | 
(5 rows)

SET client_min_messages = WARNING;
\echo 'The next 2 queries will differ in output between UTC and EST since the mod is on the 100th hour UTC'
The next 2 queries will differ in output between UTC and EST since the mod is on the 100th hour UTC
SET timezone = 'UTC';
SELECT date_group("timeCustom", '100 days') AS time, sum(series_0)
FROM PUBLIC."testNs" GROUP BY time ORDER BY time ASC;
        time         | sum 
---------------------+-----
 2009-09-13 00:00:00 | 8.5
(1 row)

SET timezone = 'EST';
SELECT date_group("timeCustom", '100 days') AS time, sum(series_0)
FROM PUBLIC."testNs" GROUP BY time ORDER BY time ASC;
        time         | sum 
---------------------+-----
 2009-09-12 19:00:00 | 8.5
(1 row)

\echo 'The rest of the queries will be the same in output between UTC and EST'
The rest of the queries will be the same in output between UTC and EST
--have to set the timezones on both Test1 and test2. Have to also kill ongoing dblinks as their sessions cache the timezone setting.
SET timezone = 'UTC';
ALTER DATABASE test2 SET timezone ='UTC';
SELECT dblink_disconnect(conn) FROM unnest(dblink_get_connections()) conn;
 dblink_disconnect 
-------------------
(0 rows)

SELECT date_group("timeCustom", '1 day') AS time, sum(series_0)
FROM PUBLIC."testNs" GROUP BY time ORDER BY time ASC;
        time         | sum 
---------------------+-----
 2009-11-10 00:00:00 | 5.5
 2009-11-12 00:00:00 |   3
(2 rows)

SET timezone = 'EST';
ALTER DATABASE test2 SET timezone ='EST';
SELECT dblink_disconnect(conn) FROM unnest(dblink_get_connections()) conn;
 dblink_disconnect 
-------------------
(0 rows)

SELECT date_group("timeCustom", '1 day') AS time, sum(series_0)
FROM PUBLIC."testNs" GROUP BY time ORDER BY time ASC;
        time         | sum 
---------------------+-----
 2009-11-09 19:00:00 | 5.5
 2009-11-11 19:00:00 |   3
(2 rows)

SET timezone = 'UTC';
ALTER DATABASE test2 SET timezone ='UTC';
SELECT dblink_disconnect(conn) FROM unnest(dblink_get_connections()) conn;
 dblink_disconnect 
-------------------
(0 rows)

SELECT *
FROM PUBLIC."testNs"
WHERE "timeCustom" >= TIMESTAMP '2009-11-10T23:00:00'
AND "timeCustom" < TIMESTAMP '2009-11-12T01:00:00' ORDER BY "timeCustom" DESC;
     timeCustom      | device_id | series_0 | series_1 | series_2 | series_bool 
---------------------+-----------+----------+----------+----------+-------------
 2009-11-10 23:00:02 | dev1      |      2.5 |        3 |          | 
 2009-11-10 23:00:00 | dev2      |      1.5 |        1 |          | 
 2009-11-10 23:00:00 | dev2      |      1.5 |        2 |          | 
(3 rows)

SET timezone = 'EST';
ALTER DATABASE test2 SET timezone ='EST';
SELECT dblink_disconnect(conn) FROM unnest(dblink_get_connections()) conn;
 dblink_disconnect 
-------------------
(0 rows)

SELECT *
FROM PUBLIC."testNs"
WHERE "timeCustom" >= TIMESTAMP '2009-11-10T23:00:00'
AND "timeCustom" < TIMESTAMP '2009-11-12T01:00:00' ORDER BY "timeCustom" DESC;
     timeCustom      | device_id | series_0 | series_1 | series_2 | series_bool 
---------------------+-----------+----------+----------+----------+-------------
 2009-11-10 23:00:02 | dev1      |      2.5 |        3 |          | 
 2009-11-10 23:00:00 | dev2      |      1.5 |        1 |          | 
 2009-11-10 23:00:00 | dev2      |      1.5 |        2 |          | 
(3 rows)

SET timezone = 'UTC';
ALTER DATABASE test2 SET timezone ='UTC';
SELECT dblink_disconnect(conn) FROM unnest(dblink_get_connections()) conn;
 dblink_disconnect 
-------------------
(0 rows)

SELECT date_group("timeCustom", '1 day') AS time, sum(series_0)
FROM PUBLIC."testNs" GROUP BY time ORDER BY time ASC LIMIT 2;
        time         | sum 
---------------------+-----
 2009-11-10 00:00:00 | 5.5
 2009-11-12 00:00:00 |   3
(2 rows)

SET timezone = 'EST';
ALTER DATABASE test2 SET timezone ='EST';
SELECT dblink_disconnect(conn) FROM unnest(dblink_get_connections()) conn;
 dblink_disconnect 
-------------------
(0 rows)

SELECT date_group("timeCustom", '1 day') AS time, sum(series_0)
FROM PUBLIC."testNs" GROUP BY time ORDER BY time ASC LIMIT 2;
        time         | sum 
---------------------+-----
 2009-11-09 19:00:00 | 5.5
 2009-11-11 19:00:00 |   3
(2 rows)

